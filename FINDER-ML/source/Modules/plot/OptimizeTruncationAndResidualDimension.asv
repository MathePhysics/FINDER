function OptimizeTruncationAndResidualDimension(Datas, parameters, methods, results)

map.Sep = zeros(parameters.data.numofgene); 
map.Close = map.Sep;

Datas.A.Training = Datas.rawdata.AData;
Datas.B.Training = Datas.rawdata.BData;
Datas.A.Testing = sparse(parameters.data.numofgene, 1);
Datas.B.Testing = Datas.A.Testing;


ZA = Datas.A.Training - mean(Datas.A.Training,2);

[Datas.A.eigenvectors, ~, ~] = svd(ZA);

for ima = 1:parameters.data.numofgene
    for imres = 1:ima
        results.current_ima = ima; results.current_imres = imres;

        for machine = ["Sep", "Close"]

        Datas = ConstructOptimalBasis(Datas,parameters,methods,results,machine);


        r = norm(mean(Datas.B.Training, 2)); %= distance between class means
        numA = mean(sum(Datas.A.Training.^2,1));
        ZB = Datas.B.Training - mean(Datas.B.Training, 2);
        numB = mean( sum(ZB.^2, 1) );
        ErrorBoundFunction = @(rA) numA / rA^2 + numB / (r - rA)^2 ;
        switch machine
            case "Sep"
            ErrorBound = fminbnd(ErrorBoundFunction,0,r);
            
            
            case "Close"
            ErrorBound = numB / numA;
            fprintf('Ratio of Class B concentration to Class A: %0.3e \n\n', ErrorBound);
        end

        map.(machine)(ima, imres) = ErrorBound;



        end
    end
end

[bestEB, ibest] = min(maps.Sep( maps.Sep ~= 0));
[MA, Mres] = ind2sub(size(maps.Sep), ibest);
fprintf('Separate means assumed \n Type I + Type II error = %0.3e \n', bestEB);
fprintf('Best MA: %d, Best Mres: %d', MA, Mres)